head	1.10;
access;
symbols
	v1_57_0_739:1.9
	v1_57_0_738:1.9
	v1_57_0_737:1.9
	v1_57_0_736:1.9
	v1_57_0_735:1.9
	v1_57_0_734:1.9
	v1_57_0_733:1.9
	v1_57_0_732:1.9
	v1_57_0_731:1.9
	v1_57_0_730:1.9
	v1_57_0_729:1.9
	v1_57_0_728:1.9
	v1_57_0_727:1.9
	v1_57_0_726:1.9
	v1_57_0_725:1.9
	v1_57_0_723:1.9
	v1_57_0_722:1.9
	v1_57_0_720:1.9
	v1_57_0_719:1.9
	v1_57_0_718:1.9
	v1_56_2_724:1.9
	v1_56_2_722:1.9
	v1_56_1_717:1.9
	v1_56_1_716:1.9
	v1_56_0_721:1.9
	v1_56_0_716:1.9
	v1_56_0_715:1.9
	v1_56_0_714:1.9
	v1_56_0_713:1.9
	v1_56_0_712:1.9
	v1_56_0_711:1.9
	v1_56_0_710:1.9
	v1_56_0_709:1.9
	v1_56_0_708:1.9
	v1_56_0_707:1.9
	v1_56_0_706:1.9
	v1_56_0_705:1.9
	v1_56_0_704:1.9
	v1_56_0_703:1.9
	v1_56_0_702:1.9
	v1_56_0_701:1.9
	v1_56_0_700:1.9
	v1_56_0_699:1.9
	v1_56_0_698:1.9
	v1_55_1_697:1.9
	v1_55_0_697:1.9
	v1_55_0_696:1.9
	v1_55_0_695:1.9
	v1_55_0_694:1.9
	v1_55_0_693:1.9
	v1_55_0_692:1.9
	v1_54_1_691:1.9
	v1_54_0_690:1.9
	v1_54_0_689:1.9
	marged_bRESPOPUP:1.9
	v1_54_0_688:1.8
	v1_54_0_687:1.7
	v1_54_0_686:1.7
	v1_54_0_685:1.7
	v1_54_0_684:1.6
	v1_54_0_683:1.6
	v1_54_0_682:1.6
	v1_54_0_681:1.6
	v1_54_0_680:1.6
	v1_54_0_679:1.6
	v1_54_0_678:1.6
	v1_54_0_677:1.6
	v1_54_0_676:1.6
	v1_54_0_675:1.6
	v1_54_0_674:1.6
	v1_53_1_673:1.6
	v1_53_0_672:1.6
	v1_53_0_671:1.6
	v1_53_0_670:1.6
	v1_53_0_669:1.6
	v1_53_0_668:1.6
	v1_53_0_667:1.6
	v1_53_0_666:1.6
	v1_53_0_665:1.6
	v1_53_0_664:1.6
	v1_53_0_663:1.6
	v1_53_0_662:1.6
	v1_53_0_661:1.6
	v1_52_1_658:1.6
	v1_52_1_657:1.6
	v1_52_0_660:1.6
	v1_52_0_656:1.6
	v1_52_0_655:1.6
	v1_52_0_654:1.6
	v1_52_0_652:1.6
	v1_52_0_651:1.6
	v1_52_0_650:1.6
	v1_52_0_649:1.6
	v1_52_0_648:1.6
	v1_52_0_647:1.6
	root-of-Bb53:1.6
	v1_52_0_646:1.4
	v1_52_0_645:1.4
	v1_52_0_644:1.4
	v1_52_0_643:1.4
	v1_52_0_642:1.4
	v1_51_1_641:1.4
	v1_51_1_640:1.4
	v1_51_1_639:1.4
	v1_51_0_638:1.4
	v1_51_0_637:1.4
	v1_51_0_636:1.4
	v1_51_0_635:1.4
	v1_51_0_634:1.4
	v1_51_0_633:1.4
	v1_51_0_632:1.4
	v1_51_0_631:1.4
	v1_51_0_630:1.4
	v1_51_0_629:1.4
	root-of-Bb51:1.4
	b51:1.4
	v1_51_0_628:1.2
	v1_51_0_627:1.2
	v1_51_0_626:1.2
	v1_51_0_625:1.2
	v1_51_0_624:1.2
	v1_51_0_623:1.2
	v1_51_0_622:1.2
	v1_51_0_621:1.2
	v1_51_0_620:1.2
	v1_51_0_619:1.2
	v1_51_0_618:1.2
	v1_51_0_617:1.2
	v1_51_0_616:1.2
	v1_51_0_615:1.2
	v1_51_0_614:1.2
	v1_51_0_613:1.2
	v1_51_0_612:1.2
	v1_51_0_611:1.2
	root-of-draw:1.2
	marged-Bb50:1.2
	v1_62_0_804:1.10
	v1_62_0_803:1.10
	v1_62_0_802:1.10
	v1_61_1_801:1.10
	v1_61_0_800:1.10
	v1_61_0_799:1.10
	v1_61_0_798:1.10
	v1_61_0_797:1.10
	v1_61_0_796:1.10
	v1_61_0_795:1.10
	v1_60_2_794:1.10
	v1_60_1_793:1.10
	v1_60_0_793:1.10
	v1_60_0_792:1.10
	v1_60_0_791:1.10
	v1_60_0_790:1.10
	v1_60_0_789:1.10
	v1_60_0_788:1.10
	v1_60_0_787:1.10
	v1_60_0_786:1.10
	v1_60_0_784:1.10
	v1_60_0_783:1.10
	v1_60_0_782:1.10
	v1_60_0_781:1.10
	v1_60_0_780:1.10
	v1_60_0_779:1.10
	v1_59_2_785:1.10
	v1_59_1_778:1.10
	v1_59_1_765:1.10
	v1_59_0_778:1.10
	v1_59_0_777:1.10
	v1_59_0_776:1.10
	v1_59_0_775:1.10
	v1_59_0_774:1.10
	v1_59_0_773:1.10
	v1_59_0_772:1.10
	v1_59_0_771:1.10
	v1_59_0_770:1.10
	v1_59_0_769:1.10
	v1_59_0_768:1.10
	v1_59_0_767:1.10
	v1_58_0_763:1.10
	v1_58_0_762:1.10
	v1_58_0_761:1.10
	v1_58_0_760:1.10
	v1_58_0_759:1.10
	v1_58_0_757:1.10
	v1_58_0_756:1.10
	v1_58_0_755:1.10
	v1_58_0_754:1.10
	v1_58_0_752:1.10
	v1_58_0_751:1.10
	v1_58_0_750:1.10
	v1_58_0_748:1.10
	v1_58_0_747:1.10
	v1_58_0_746:1.10
	v1_58_0_745:1.10
	v1_57_2_749:1.10
	v1_57_1_744:1.10
	v1_57_0_744:1.10
	v1_57_0_743:1.10
	v1_57_0_742:1.10
	v1_57_0_741:1.10
	v1_57_0_740:1.10
	v1_50_2_606:1.1.4.1
	v1_50_2_604:1.1.4.1
	v1_50_0_606:1.1.4.1
	v1_50_0_605:1.1.4.1
	v1_50_0_604:1.1.4.1
	v1_50_0_603:1.1.4.1
	v1_50_0_602:1.1.4.1
	v1_50_0_601:1.1.4.1
	v1_50_0_600:1.1.4.1
	v1_50_0_599:1.1.4.1
	v1_50_0_598:1.1.4.1
	v1_50_0_596:1.1.4.1
	v1_50_0_595:1.1.4.1
	b50:1.1.4.1
	Bb50:1.1.0.4
	v_step1:1.1
	v1_50_0_594:1.1
	v1_50_0_593:1.1
	v1_50_0_590:1.1
	v1_50_0_588:1.1
	v1_50_0_587:1.1
	v1_50_0_586:1.1
	v1_50_0_585:1.1
	v1_50_0_584:1.1
	v1_50_0_582:1.1
	v1_50_0_581:1.1
	v1_50_0_580:1.1
	v1_50_0_579:1.1
	v1_50_0_578:1.1
	v1_50_0_577:1.1
	v1_50_0_576:1.1
	v1_50_0_574:1.1
	v1_50_0_573:1.1
	v1_50_0_572:1.1
	v1_50_0_571:1.1
	v1_50_0_561:1.1
	v1_50_0_557:1.1
	root-of-remodel:1.1
	root-of-Bb50:1.1
	merged-remodeling:1.1
	bv1_49_0_565:1.1
	bv1_49_0_564:1.1
	bv1_49_0_563:1.1;
locks; strict;
comment	@# @;
expand	@b@;


1.10
date	2008.02.11.13.46.13;	author h677;	state Exp;
branches;
next	1.9;

1.9
date	2007.01.14.13.40.25;	author h677;	state Exp;
branches;
next	1.8;

1.8
date	2007.01.06.13.55.29;	author h677;	state Exp;
branches;
next	1.7;

1.7
date	2006.12.24.15.21.09;	author h677;	state Exp;
branches;
next	1.6;

1.6
date	2006.02.22.17.21.22;	author h677;	state Exp;
branches;
next	1.5;

1.5
date	2006.02.21.15.35.49;	author h677;	state Exp;
branches;
next	1.4;

1.4
date	2005.12.14.17.04.56;	author h677;	state Exp;
branches;
next	1.3;

1.3
date	2005.12.14.15.14.42;	author h677;	state Exp;
branches;
next	1.2;

1.2
date	2005.07.18.03.55.14;	author h677;	state Exp;
branches;
next	1.1;

1.1
date	2004.10.11.14.38.58;	author yoffy;	state Exp;
branches
	1.1.4.1;
next	;

1.1.4.1
date	2005.07.09.05.28.35;	author h677;	state Exp;
branches;
next	;


desc
@@


1.10
log
@Hook„ÅÆÂ§âÊï∞„Åå„ÄÅÁ¨¶Âè∑‰ªòÊï¥Êï∞„Å†„Å£„Åü„ÅÆ„Åß„ÄÅÁ¨¶Âè∑ÁÑ°„ÅóÊï¥Êï∞„Å´Â§âÊõ¥„Åó„Åü„ÄÇ
@
text
@unit Gesture;

interface

uses
	Windows, Messages, SysUtils, Variants, Classes, Graphics, Controls, Forms,
	Dialogs, Math, StrUtils;

type
	TMouseGesture = class(TObject)
	private
		FHook: Cardinal;
		FHandle: THandle;
		FGestureItemList: TStringList;
		FBeginGesture: Boolean;
		FCancelMode: Boolean;
		FLastTime: Cardinal;
		FStartPoint: TPoint;
		FLastPoint: TPoint;
		FMargin: Integer;
		FOnGestureStart: TNotifyEvent;
		FOnGestureMove: TNotifyEvent;
		FOnGestureEnd: TNotifyEvent;
		function GetGestureCount: Integer;
		function CheckAction(Message: Integer; x, y: Integer): Boolean;
		procedure AddAction(sx, sy: Integer);
		function AddGesture(Item: string): Integer;
		function Get(Index: integer): string;
		procedure Put(Index: integer; Item: string);
	public
		constructor Create;
		destructor Destroy; override;
		procedure SetHook(hWnd: THandle);
		procedure UnHook;
		property Items[Index: Integer]: string read Get write Put; default;
		property GestureCount: Integer read GetGestureCount;
		property Margin: Integer read FMargin write FMargin;
		function GetGestureStr: string;
		procedure Clear;
		property OnGestureStart: TNotifyEvent read FOnGestureStart write FOnGestureStart;
		property OnGestureMove: TNotifyEvent read FOnGestureMove write FOnGestureMove;
		property OnGestureEnd: TNotifyEvent read FOnGestureEnd write FOnGestureEnd;
	end;

	function GestureProc(nCode: Integer; wParam: WPARAM; lParam: LPARAM): LRESULT; stdcall;

var
	MouseGesture: TMouseGesture;

implementation

uses
	GikoSystem;

constructor TMouseGesture.Create;
begin
	inherited;
	FHook := 0;
	FCancelMode := False;
	FBeginGesture := False;
	FMargin := 15;
	FGestureItemList := TStringList.Create;
end;

destructor TMouseGesture.Destroy;
begin
	UnHook;
	Clear;
	FGestureItemList.Free;
	inherited;
end;

//É}ÉEÉXÉtÉbÉN
procedure TMouseGesture.SetHook(hWnd: THandle);
begin
	if FHook <> 0 then
		Exit;
	FHandle := hWnd;
	UnHook;
	FHook := SetWindowsHookEx(WH_MOUSE, @@GestureProc, 0{HInstance}, GetCurrentThreadId);
end;

//É}ÉEÉXÉtÉbÉNâèú
procedure TMouseGesture.UnHook;
begin
	if FHook = 0 then
		Exit;
	UnhookWindowsHookEx(FHook);
	FHook := 0;
end;

//ÉtÉbÉNÉvÉçÉVÉWÉÉ
function GestureProc(nCode: Integer; wParam: WPARAM; lParam: LPARAM): LRESULT; stdcall;
var
	mhs: PMouseHookStruct;
begin
	if nCode = HC_ACTION then begin
		mhs := PMouseHookStruct(lParam);
		if MouseGesture.CheckAction(wParam, mhs^.pt.X, mhs^.pt.Y) then begin
			Result := 1;
			Exit;
		end;
	end;
	Result := CallNextHookEx(MouseGesture.FHook, nCode, wParam, lParam);
end;

function TMouseGesture.CheckAction(Message: Integer; x, y: Integer): Boolean;
var
	dp: TPoint;
	sp: TPoint;
	hwnd: THandle;
begin
	Result := False;
	case Message of
		WM_MOUSEMOVE: begin
			if FBeginGesture then begin
				//ç°É}ÉEÉXÇÉLÉÉÉvÉ`ÉÉÅ[ÇµÇƒÇ¢ÇÈÇÃÇìæÇÈ
				hwnd := GetCapture;
				//É}ÉEÉXÉWÉFÉXÉ`ÉÉÅ[ÇÃëŒè€Ç∆à·Ç§Ç∆Ç´ÇÕÅAäJï˙Ç∑ÇÈ
				if (hwnd <> 0) and (hwnd <> FHandle) then begin
					ReleaseCapture;
                    SetCapture(FHandle);
				end;
				dp := Point(x - FLastPoint.X, y - FLastPoint.Y);
				sp := Point(Sign(dp.X), Sign(dp.Y));
				if (dp.X * dp.X + dp.Y * dp.Y) > (FMargin * FMargin) then begin
					dp := Point(Abs(dp.X), Abs(dp.Y));
					if dp.X > dp.Y div 3 then
						sp.Y := 0;
					if dp.Y > dp.X div 3 then
						sp.X := 0;
					AddAction(sp.X, sp.Y);
					FLastTime := GetTickCount;
					FLastPoint := Point(x, y);
				end;
                Result := True;
    		end;
		end;
		WM_RBUTTONDOWN: begin
			if (not FCancelMode)  then begin
                if ( GikoSys.Setting.GestureIgnoreContext ) then begin
    				//ç°É}ÉEÉXÇÉLÉÉÉvÉ`ÉÉÅ[ÇµÇƒÇ¢ÇÈÇÃÇìæÇÈ
	    			hwnd := GetCapture;
		    		//É}ÉEÉXÉWÉFÉXÉ`ÉÉÅ[ÇÃëŒè€Ç∆à·Ç§Ç∆Ç´ÇÕÅAäJï˙Ç∑ÇÈ
			    	if (hwnd <> 0) and (hwnd <> FHandle) then begin
                        Exit;
                    end;
                end;
				FBeginGesture := True;
				FLastTime := 0;
				FLastPoint := Point(x, y);
				FStartPoint := Point(x, y);
				Result := True;
				SetCapture(FHandle);
			end;
		end;
		WM_RBUTTONUP: begin
			if FCancelMode then
				FCancelMode := False
			else if (FBeginGesture) then begin
				FBeginGesture := False;
				ReleaseCapture;
				if FGestureItemList.Count <> 0 then begin
					if Assigned(FOnGestureEnd) then begin
						FOnGestureEnd(Self);
                    end else begin
                        Clear;
                    end;
				end else begin
					FCancelMode := True;
					//ÉWÉFÉXÉ`ÉÉÅ[Ç∂Ç·Ç»Ç©Ç¡ÇΩèÍçáÅAÉ}ÉEÉXDOWN,UPÇÉGÉ~ÉÖÉåÅ[Ég
					mouse_event(MOUSEEVENTF_ABSOLUTE or MOUSEEVENTF_RIGHTDOWN, FStartPoint.X, FStartPoint.Y, 0, 0);
					mouse_event(MOUSEEVENTF_ABSOLUTE or MOUSEEVENTF_RIGHTUP, x, y, 0, 0);
				end;
			end;
		end;
	end;
end;

//ìÆçÏÇÃí«â¡
procedure TMouseGesture.AddAction(sx, sy: Integer);
var
	Direction: string;
begin
	Direction := '';
	if (sx > 0) and (sy = 0) then
		Direction := 'Å®'
	else if (sx < 0) and (sy = 0) then
		Direction := 'Å©'
	else if sy > 0 then
		Direction := 'Å´'
	else if sy < 0 then
		Direction := 'Å™'
	else
		Exit;
	if FGestureItemList.Count > 0 then begin
		if Items[FGestureItemList.Count - 1] = Direction then
			Exit;
	end else begin
		//ÉWÉFÉXÉ`ÉÉÅ[äJén
		if Assigned(FOnGestureStart) then
			FOnGestureStart(Self);
	end;
	AddGesture(Direction);
	if Assigned(FOnGestureMove) then
		FOnGestureMove(Self);
end;

//åªç›ÇÃÉWÉFÉXÉ`ÉÉÅ[Ç…êVÇµÇ¢ï˚å¸Çí«â¡
function TMouseGesture.AddGesture(Item: string): Integer;
begin
	Result := FGestureItemList.Add(Item);
end;

//éwíËÇ≥ÇÍÇΩindexÇÃìÆÇ´Çï‘Ç∑
function TMouseGesture.Get(Index: Integer): string;
begin
	Result := FGestureItemList[Index];
end;

//éwíËÇ≥ÇÍÇΩindexÇÃìÆÇ´Çê›íËÇ∑ÇÈ
procedure TMouseGesture.Put(Index: Integer; Item: string);
begin
	FGestureItemList[Index] := Item;
end;

//ÉWÉFÉXÉ`ÉÉÅ[ï∂éöóÒÇï‘Ç∑
function TMouseGesture.GetGestureStr: string;
var
	i: Integer;
begin
	Result := '';
	for i := 0 to FGestureItemList.Count - 1 do
		Result := Result + Items[i];
end;

//ÉWÉFÉXÉ`ÉÉÅ[ÇÃí∑Ç≥Çï‘Ç∑
function TMouseGesture.GetGestureCount: Integer;
begin
	Result := FGestureItemList.Count;
end;

//ÉWÉFÉXÉ`ÉÉÅ[ÇÉNÉäÉAÇ∑ÇÈ
procedure TMouseGesture.Clear;
begin
	FGestureItemList.Clear;
end;

end.
@


1.9
log
@„É¨„Çπ„Ç®„Éá„Ç£„Çø,„Ç≠„ÉºË®≠ÂÆö„Åß„Éû„Ç¶„Çπ„Ç∏„Çß„Çπ„ÉÅ„É£„Éº„ÅÆÂÖ•Âäõ„Åå„ÇØ„É™„Ç¢„Åï„Çå„Å™„ÅÑ‰∏çÂÖ∑Âêà„ÅÆ‰øÆÊ≠£
@
text
@d12 1
a12 1
		FHook: Integer;
@


1.8
log
@„Éû„Ç¶„Çπ„Ç∏„Çß„Çπ„ÉÅ„É£„Éº„Åß„ÄÅ„Ç¢„ÇØ„Ç∑„Éß„É≥„ÇíÂëº„Å≥Âá∫„Åô„Å®„ÅçÂâç„Å´„ÄÅ
„Ç∏„Çß„Çπ„ÉÅ„É£„Éº„Çí„ÇØ„É™„Ç¢„Åô„Çã„Çà„ÅÜ„Å´Â§âÊõ¥
@
text
@d39 1
a39 1
		procedure ClearGesture;
d68 1
a68 1
	ClearGesture;
d167 1
a167 1
                        ClearGesture;
d244 1
a244 1
procedure TMouseGesture.ClearGesture;
@


1.7
log
@Âè≥„ÇØ„É™„ÉÉ„ÇØ„ÅÆ„Ç≥„É≥„ÉÜ„Ç≠„Çπ„Éà„É°„Éã„É•„Éº‰∏ä„ÅÆ„Éû„Ç¶„Çπ„Ç∏„Çß„Çπ„ÉÅ„É£„Éº„ÇíÁÑ°Âäπ„Å´„Åß„Åç„Çã„Ç™„Éó„Ç∑„Éß„É≥„ÇíËøΩÂä†„ÄÇ
„Ç¢„Éâ„É¨„Çπ„Éê„Éº„Å´„Éï„Ç©„Éº„Ç´„Çπ„ÇíÂΩì„Å¶„Çã„Ç∑„Éß„Éº„Éà„Ç´„ÉÉ„Éà„ÇíËøΩÂä†„ÄÇ
@
text
@a27 1
		procedure ClearGesture;
d39 1
d164 1
a164 1
					if Assigned(FOnGestureEnd) then
d166 3
a168 1
					ClearGesture;
@


1.6
log
@datËêΩ„Å°„Çπ„É¨„ÅÆÂå∫Âà•„ÇíËøΩÂä†„Åó„Åü„ÅÆ„Åß„ÄÅ„Çπ„É¨„ÉÉ„Éâ‰∏ÄË¶ß„Çí„Åù„Çå„ÅßÁµû„ÇäËæº„ÇÅ„Çã„Çà„ÅÜ„Å´„Åó„Åü
@
text
@d52 3
d122 1
a123 1
				SetCapture(FHandle);
d136 2
a137 2
				Result := True;
			end;
d140 9
a148 1
			if not FCancelMode then begin
@


1.5
log
@„Éû„Ç¶„Çπ„Ç∏„Çß„Çπ„ÉÅ„É£„Éº-„ÅÆ‰∏çÂÖ∑Âêà„Å®„É¨„ÇπÁï™ÊåáÂÆöURL„ÇíË∏è„Çì„Å†„Å®„Åç„ÅÆÂá¶ÁêÜÁî®„Å´
TThreadItem„ÇíÊã°Âºµ
@
text
@a108 1
	r: LongBool;
@


1.4
log
@1.3„ÅÆÁõ¥„ÅóÊñπ„Å†„Å®„ÄÅ„É°„Ç§„É≥S„Éï„Ç©„Éº„É†„ÅÆ„Éù„ÉÉ„Éó„Ç¢„ÉÉ„Éó„Åå„Åä„Åã„Åó„Åè„Å™„Çã„ÅÆ„Åß„ÄÅÔºë.2Áõ∏ÂΩì„Å´
„É≠„Éº„É´„Éê„ÉÉ„ÇØ„ÄÇ
@
text
@d109 1
d150 1
a150 1
			else begin
@


1.3
log
@„Éû„Ç¶„Çπ„Ç∏„Çß„Çπ„ÉÅ„É£„ÉºÊúâÂäπÊôÇ„Å´ÁîªÂÉè„Éó„É¨„Éì„É•„Éº‰∏ä„ÅßÂè≥„ÇØ„É™„ÉÉ„ÇØ„Åå
Âäπ„Åã„Å™„ÅÑ‰∏çÂÖ∑Âêà„ÅÆ‰øÆÊ≠£„ÄÇ
@
text
@d137 8
a144 5
			FBeginGesture := True;
			FLastTime := 0;
			FLastPoint := Point(x, y);
			FStartPoint := Point(x, y);
			SetCapture(FHandle);
d147 15
a161 6
			FBeginGesture := False;
			ReleaseCapture;
			if FGestureItemList.Count <> 0 then begin
				if Assigned(FOnGestureEnd) then
					FOnGestureEnd(Self);
				ClearGesture;
@


1.2
log
@„Éè„Çõ„Çø50Ôºà1.50.1.599)„Åæ„Åß„ÅÆÂ§âÊõ¥ÂàÜ„Çí„Éû„Éº„Ç∏
@
text
@a132 4
				//É}ÉEÉXÇçƒê›íË
				if (hwnd <> 0) and (hwnd <> FHandle) then
					SetCapture(hwnd);
				
d137 5
a141 8
			if not FCancelMode then begin
				FBeginGesture := True;
				FLastTime := 0;
				FLastPoint := Point(x, y);
				FStartPoint := Point(x, y);
				CheckAction := True;
				SetCapture(FHandle);
			end;
d144 6
a149 15
			if FCancelMode then
				FCancelMode := False
			else begin
				FBeginGesture := False;
				ReleaseCapture;
				if FGestureItemList.Count <> 0 then begin
					if Assigned(FOnGestureEnd) then
						FOnGestureEnd(Self);
					ClearGesture;
				end else begin
					FCancelMode := True;
					//ÉWÉFÉXÉ`ÉÉÅ[Ç∂Ç·Ç»Ç©Ç¡ÇΩèÍçáÅAÉ}ÉEÉXDOWN,UPÇÉGÉ~ÉÖÉåÅ[Ég
					mouse_event(MOUSEEVENTF_ABSOLUTE or MOUSEEVENTF_RIGHTDOWN, FStartPoint.X, FStartPoint.Y, 0, 0);
					mouse_event(MOUSEEVENTF_ABSOLUTE or MOUSEEVENTF_RIGHTUP, x, y, 0, 0);
				end;
@


1.1
log
@„Éû„Ç¶„Çπ„Ç∏„Çß„Çπ„ÉÅ„É£„ÅÆËøΩÂä†„ÄÇ
build557
@
text
@d108 1
d114 6
d123 1
a123 1
				if Sqrt(dp.X * dp.X + dp.Y * dp.Y) > FMargin then begin
d125 1
a125 1
					if dp.X > dp.Y / 3 then
d127 1
a127 1
					if dp.Y > dp.X / 3 then
d133 4
@


1.1.4.1
log
@„Éû„Ç¶„Çπ„Ç∏„Çß„Çπ„ÉÅ„É£„Éº„ÅÆ„Ç≥„É≥„ÉÜ„Ç≠„Çπ„Éà‰∏ä„Å®„Åã„Åß„ÅÆÂãï‰Ωú„ÅÆ‰øÆÊ≠£
@
text
@a107 1
	hwnd: THandle;
a112 6
				//ç°É}ÉEÉXÇÉLÉÉÉvÉ`ÉÉÅ[ÇµÇƒÇ¢ÇÈÇÃÇìæÇÈ
				hwnd := GetCapture;
				//É}ÉEÉXÉWÉFÉXÉ`ÉÉÅ[ÇÃëŒè€Ç∆à·Ç§Ç∆Ç´ÇÕÅAäJï˙Ç∑ÇÈ
				if (hwnd <> 0) and (hwnd <> FHandle) then begin
					ReleaseCapture;
				end;
d116 1
a116 1
				if (dp.X * dp.X + dp.Y * dp.Y) > (FMargin * FMargin) then begin
d118 1
a118 1
					if dp.X > dp.Y div 3 then
d120 1
a120 1
					if dp.Y > dp.X div 3 then
a125 4
				//É}ÉEÉXÇçƒê›íË
				if (hwnd <> 0) and (hwnd <> FHandle) then
					SetCapture(hwnd);
				
@

