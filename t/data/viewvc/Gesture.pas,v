head	1.10;
access;
symbols
	v1_57_0_739:1.9
	v1_57_0_738:1.9
	v1_57_0_737:1.9
	v1_57_0_736:1.9
	v1_57_0_735:1.9
	v1_57_0_734:1.9
	v1_57_0_733:1.9
	v1_57_0_732:1.9
	v1_57_0_731:1.9
	v1_57_0_730:1.9
	v1_57_0_729:1.9
	v1_57_0_728:1.9
	v1_57_0_727:1.9
	v1_57_0_726:1.9
	v1_57_0_725:1.9
	v1_57_0_723:1.9
	v1_57_0_722:1.9
	v1_57_0_720:1.9
	v1_57_0_719:1.9
	v1_57_0_718:1.9
	v1_56_2_724:1.9
	v1_56_2_722:1.9
	v1_56_1_717:1.9
	v1_56_1_716:1.9
	v1_56_0_721:1.9
	v1_56_0_716:1.9
	v1_56_0_715:1.9
	v1_56_0_714:1.9
	v1_56_0_713:1.9
	v1_56_0_712:1.9
	v1_56_0_711:1.9
	v1_56_0_710:1.9
	v1_56_0_709:1.9
	v1_56_0_708:1.9
	v1_56_0_707:1.9
	v1_56_0_706:1.9
	v1_56_0_705:1.9
	v1_56_0_704:1.9
	v1_56_0_703:1.9
	v1_56_0_702:1.9
	v1_56_0_701:1.9
	v1_56_0_700:1.9
	v1_56_0_699:1.9
	v1_56_0_698:1.9
	v1_55_1_697:1.9
	v1_55_0_697:1.9
	v1_55_0_696:1.9
	v1_55_0_695:1.9
	v1_55_0_694:1.9
	v1_55_0_693:1.9
	v1_55_0_692:1.9
	v1_54_1_691:1.9
	v1_54_0_690:1.9
	v1_54_0_689:1.9
	marged_bRESPOPUP:1.9
	v1_54_0_688:1.8
	v1_54_0_687:1.7
	v1_54_0_686:1.7
	v1_54_0_685:1.7
	v1_54_0_684:1.6
	v1_54_0_683:1.6
	v1_54_0_682:1.6
	v1_54_0_681:1.6
	v1_54_0_680:1.6
	v1_54_0_679:1.6
	v1_54_0_678:1.6
	v1_54_0_677:1.6
	v1_54_0_676:1.6
	v1_54_0_675:1.6
	v1_54_0_674:1.6
	v1_53_1_673:1.6
	v1_53_0_672:1.6
	v1_53_0_671:1.6
	v1_53_0_670:1.6
	v1_53_0_669:1.6
	v1_53_0_668:1.6
	v1_53_0_667:1.6
	v1_53_0_666:1.6
	v1_53_0_665:1.6
	v1_53_0_664:1.6
	v1_53_0_663:1.6
	v1_53_0_662:1.6
	v1_53_0_661:1.6
	v1_52_1_658:1.6
	v1_52_1_657:1.6
	v1_52_0_660:1.6
	v1_52_0_656:1.6
	v1_52_0_655:1.6
	v1_52_0_654:1.6
	v1_52_0_652:1.6
	v1_52_0_651:1.6
	v1_52_0_650:1.6
	v1_52_0_649:1.6
	v1_52_0_648:1.6
	v1_52_0_647:1.6
	root-of-Bb53:1.6
	v1_52_0_646:1.4
	v1_52_0_645:1.4
	v1_52_0_644:1.4
	v1_52_0_643:1.4
	v1_52_0_642:1.4
	v1_51_1_641:1.4
	v1_51_1_640:1.4
	v1_51_1_639:1.4
	v1_51_0_638:1.4
	v1_51_0_637:1.4
	v1_51_0_636:1.4
	v1_51_0_635:1.4
	v1_51_0_634:1.4
	v1_51_0_633:1.4
	v1_51_0_632:1.4
	v1_51_0_631:1.4
	v1_51_0_630:1.4
	v1_51_0_629:1.4
	root-of-Bb51:1.4
	b51:1.4
	v1_51_0_628:1.2
	v1_51_0_627:1.2
	v1_51_0_626:1.2
	v1_51_0_625:1.2
	v1_51_0_624:1.2
	v1_51_0_623:1.2
	v1_51_0_622:1.2
	v1_51_0_621:1.2
	v1_51_0_620:1.2
	v1_51_0_619:1.2
	v1_51_0_618:1.2
	v1_51_0_617:1.2
	v1_51_0_616:1.2
	v1_51_0_615:1.2
	v1_51_0_614:1.2
	v1_51_0_613:1.2
	v1_51_0_612:1.2
	v1_51_0_611:1.2
	root-of-draw:1.2
	marged-Bb50:1.2
	v1_62_0_804:1.10
	v1_62_0_803:1.10
	v1_62_0_802:1.10
	v1_61_1_801:1.10
	v1_61_0_800:1.10
	v1_61_0_799:1.10
	v1_61_0_798:1.10
	v1_61_0_797:1.10
	v1_61_0_796:1.10
	v1_61_0_795:1.10
	v1_60_2_794:1.10
	v1_60_1_793:1.10
	v1_60_0_793:1.10
	v1_60_0_792:1.10
	v1_60_0_791:1.10
	v1_60_0_790:1.10
	v1_60_0_789:1.10
	v1_60_0_788:1.10
	v1_60_0_787:1.10
	v1_60_0_786:1.10
	v1_60_0_784:1.10
	v1_60_0_783:1.10
	v1_60_0_782:1.10
	v1_60_0_781:1.10
	v1_60_0_780:1.10
	v1_60_0_779:1.10
	v1_59_2_785:1.10
	v1_59_1_778:1.10
	v1_59_1_765:1.10
	v1_59_0_778:1.10
	v1_59_0_777:1.10
	v1_59_0_776:1.10
	v1_59_0_775:1.10
	v1_59_0_774:1.10
	v1_59_0_773:1.10
	v1_59_0_772:1.10
	v1_59_0_771:1.10
	v1_59_0_770:1.10
	v1_59_0_769:1.10
	v1_59_0_768:1.10
	v1_59_0_767:1.10
	v1_58_0_763:1.10
	v1_58_0_762:1.10
	v1_58_0_761:1.10
	v1_58_0_760:1.10
	v1_58_0_759:1.10
	v1_58_0_757:1.10
	v1_58_0_756:1.10
	v1_58_0_755:1.10
	v1_58_0_754:1.10
	v1_58_0_752:1.10
	v1_58_0_751:1.10
	v1_58_0_750:1.10
	v1_58_0_748:1.10
	v1_58_0_747:1.10
	v1_58_0_746:1.10
	v1_58_0_745:1.10
	v1_57_2_749:1.10
	v1_57_1_744:1.10
	v1_57_0_744:1.10
	v1_57_0_743:1.10
	v1_57_0_742:1.10
	v1_57_0_741:1.10
	v1_57_0_740:1.10
	v1_50_2_606:1.1.4.1
	v1_50_2_604:1.1.4.1
	v1_50_0_606:1.1.4.1
	v1_50_0_605:1.1.4.1
	v1_50_0_604:1.1.4.1
	v1_50_0_603:1.1.4.1
	v1_50_0_602:1.1.4.1
	v1_50_0_601:1.1.4.1
	v1_50_0_600:1.1.4.1
	v1_50_0_599:1.1.4.1
	v1_50_0_598:1.1.4.1
	v1_50_0_596:1.1.4.1
	v1_50_0_595:1.1.4.1
	b50:1.1.4.1
	Bb50:1.1.0.4
	v_step1:1.1
	v1_50_0_594:1.1
	v1_50_0_593:1.1
	v1_50_0_590:1.1
	v1_50_0_588:1.1
	v1_50_0_587:1.1
	v1_50_0_586:1.1
	v1_50_0_585:1.1
	v1_50_0_584:1.1
	v1_50_0_582:1.1
	v1_50_0_581:1.1
	v1_50_0_580:1.1
	v1_50_0_579:1.1
	v1_50_0_578:1.1
	v1_50_0_577:1.1
	v1_50_0_576:1.1
	v1_50_0_574:1.1
	v1_50_0_573:1.1
	v1_50_0_572:1.1
	v1_50_0_571:1.1
	v1_50_0_561:1.1
	v1_50_0_557:1.1
	root-of-remodel:1.1
	root-of-Bb50:1.1
	merged-remodeling:1.1
	bv1_49_0_565:1.1
	bv1_49_0_564:1.1
	bv1_49_0_563:1.1;
locks; strict;
comment	@# @;
expand	@b@;


1.10
date	2008.02.11.13.46.13;	author h677;	state Exp;
branches;
next	1.9;

1.9
date	2007.01.14.13.40.25;	author h677;	state Exp;
branches;
next	1.8;

1.8
date	2007.01.06.13.55.29;	author h677;	state Exp;
branches;
next	1.7;

1.7
date	2006.12.24.15.21.09;	author h677;	state Exp;
branches;
next	1.6;

1.6
date	2006.02.22.17.21.22;	author h677;	state Exp;
branches;
next	1.5;

1.5
date	2006.02.21.15.35.49;	author h677;	state Exp;
branches;
next	1.4;

1.4
date	2005.12.14.17.04.56;	author h677;	state Exp;
branches;
next	1.3;

1.3
date	2005.12.14.15.14.42;	author h677;	state Exp;
branches;
next	1.2;

1.2
date	2005.07.18.03.55.14;	author h677;	state Exp;
branches;
next	1.1;

1.1
date	2004.10.11.14.38.58;	author yoffy;	state Exp;
branches
	1.1.4.1;
next	;

1.1.4.1
date	2005.07.09.05.28.35;	author h677;	state Exp;
branches;
next	;


desc
@@


1.10
log
@Hookã®å¤‰æ•°ãŒã€ç¬¦å·ä»˜æ•´æ•°ã ã£ãŸã®ã§ã€ç¬¦å·ç„¡ã—æ•´æ•°ã«å¤‰æ›´ã—ãŸã€‚
@
text
@unit Gesture;

interface

uses
	Windows, Messages, SysUtils, Variants, Classes, Graphics, Controls, Forms,
	Dialogs, Math, StrUtils;

type
	TMouseGesture = class(TObject)
	private
		FHook: Cardinal;
		FHandle: THandle;
		FGestureItemList: TStringList;
		FBeginGesture: Boolean;
		FCancelMode: Boolean;
		FLastTime: Cardinal;
		FStartPoint: TPoint;
		FLastPoint: TPoint;
		FMargin: Integer;
		FOnGestureStart: TNotifyEvent;
		FOnGestureMove: TNotifyEvent;
		FOnGestureEnd: TNotifyEvent;
		function GetGestureCount: Integer;
		function CheckAction(Message: Integer; x, y: Integer): Boolean;
		procedure AddAction(sx, sy: Integer);
		function AddGesture(Item: string): Integer;
		function Get(Index: integer): string;
		procedure Put(Index: integer; Item: string);
	public
		constructor Create;
		destructor Destroy; override;
		procedure SetHook(hWnd: THandle);
		procedure UnHook;
		property Items[Index: Integer]: string read Get write Put; default;
		property GestureCount: Integer read GetGestureCount;
		property Margin: Integer read FMargin write FMargin;
		function GetGestureStr: string;
		procedure Clear;
		property OnGestureStart: TNotifyEvent read FOnGestureStart write FOnGestureStart;
		property OnGestureMove: TNotifyEvent read FOnGestureMove write FOnGestureMove;
		property OnGestureEnd: TNotifyEvent read FOnGestureEnd write FOnGestureEnd;
	end;

	function GestureProc(nCode: Integer; wParam: WPARAM; lParam: LPARAM): LRESULT; stdcall;

var
	MouseGesture: TMouseGesture;

implementation

uses
	GikoSystem;

constructor TMouseGesture.Create;
begin
	inherited;
	FHook := 0;
	FCancelMode := False;
	FBeginGesture := False;
	FMargin := 15;
	FGestureItemList := TStringList.Create;
end;

destructor TMouseGesture.Destroy;
begin
	UnHook;
	Clear;
	FGestureItemList.Free;
	inherited;
end;

//ƒ}ƒEƒXƒtƒbƒN
procedure TMouseGesture.SetHook(hWnd: THandle);
begin
	if FHook <> 0 then
		Exit;
	FHandle := hWnd;
	UnHook;
	FHook := SetWindowsHookEx(WH_MOUSE, @@GestureProc, 0{HInstance}, GetCurrentThreadId);
end;

//ƒ}ƒEƒXƒtƒbƒN‰ğœ
procedure TMouseGesture.UnHook;
begin
	if FHook = 0 then
		Exit;
	UnhookWindowsHookEx(FHook);
	FHook := 0;
end;

//ƒtƒbƒNƒvƒƒVƒWƒƒ
function GestureProc(nCode: Integer; wParam: WPARAM; lParam: LPARAM): LRESULT; stdcall;
var
	mhs: PMouseHookStruct;
begin
	if nCode = HC_ACTION then begin
		mhs := PMouseHookStruct(lParam);
		if MouseGesture.CheckAction(wParam, mhs^.pt.X, mhs^.pt.Y) then begin
			Result := 1;
			Exit;
		end;
	end;
	Result := CallNextHookEx(MouseGesture.FHook, nCode, wParam, lParam);
end;

function TMouseGesture.CheckAction(Message: Integer; x, y: Integer): Boolean;
var
	dp: TPoint;
	sp: TPoint;
	hwnd: THandle;
begin
	Result := False;
	case Message of
		WM_MOUSEMOVE: begin
			if FBeginGesture then begin
				//¡ƒ}ƒEƒX‚ğƒLƒƒƒvƒ`ƒƒ[‚µ‚Ä‚¢‚é‚Ì‚ğ“¾‚é
				hwnd := GetCapture;
				//ƒ}ƒEƒXƒWƒFƒXƒ`ƒƒ[‚Ì‘ÎÛ‚Æˆá‚¤‚Æ‚«‚ÍAŠJ•ú‚·‚é
				if (hwnd <> 0) and (hwnd <> FHandle) then begin
					ReleaseCapture;
                    SetCapture(FHandle);
				end;
				dp := Point(x - FLastPoint.X, y - FLastPoint.Y);
				sp := Point(Sign(dp.X), Sign(dp.Y));
				if (dp.X * dp.X + dp.Y * dp.Y) > (FMargin * FMargin) then begin
					dp := Point(Abs(dp.X), Abs(dp.Y));
					if dp.X > dp.Y div 3 then
						sp.Y := 0;
					if dp.Y > dp.X div 3 then
						sp.X := 0;
					AddAction(sp.X, sp.Y);
					FLastTime := GetTickCount;
					FLastPoint := Point(x, y);
				end;
                Result := True;
    		end;
		end;
		WM_RBUTTONDOWN: begin
			if (not FCancelMode)  then begin
                if ( GikoSys.Setting.GestureIgnoreContext ) then begin
    				//¡ƒ}ƒEƒX‚ğƒLƒƒƒvƒ`ƒƒ[‚µ‚Ä‚¢‚é‚Ì‚ğ“¾‚é
	    			hwnd := GetCapture;
		    		//ƒ}ƒEƒXƒWƒFƒXƒ`ƒƒ[‚Ì‘ÎÛ‚Æˆá‚¤‚Æ‚«‚ÍAŠJ•ú‚·‚é
			    	if (hwnd <> 0) and (hwnd <> FHandle) then begin
                        Exit;
                    end;
                end;
				FBeginGesture := True;
				FLastTime := 0;
				FLastPoint := Point(x, y);
				FStartPoint := Point(x, y);
				Result := True;
				SetCapture(FHandle);
			end;
		end;
		WM_RBUTTONUP: begin
			if FCancelMode then
				FCancelMode := False
			else if (FBeginGesture) then begin
				FBeginGesture := False;
				ReleaseCapture;
				if FGestureItemList.Count <> 0 then begin
					if Assigned(FOnGestureEnd) then begin
						FOnGestureEnd(Self);
                    end else begin
                        Clear;
                    end;
				end else begin
					FCancelMode := True;
					//ƒWƒFƒXƒ`ƒƒ[‚¶‚á‚È‚©‚Á‚½ê‡Aƒ}ƒEƒXDOWN,UP‚ğƒGƒ~ƒ…ƒŒ[ƒg
					mouse_event(MOUSEEVENTF_ABSOLUTE or MOUSEEVENTF_RIGHTDOWN, FStartPoint.X, FStartPoint.Y, 0, 0);
					mouse_event(MOUSEEVENTF_ABSOLUTE or MOUSEEVENTF_RIGHTUP, x, y, 0, 0);
				end;
			end;
		end;
	end;
end;

//“®ì‚Ì’Ç‰Á
procedure TMouseGesture.AddAction(sx, sy: Integer);
var
	Direction: string;
begin
	Direction := '';
	if (sx > 0) and (sy = 0) then
		Direction := '¨'
	else if (sx < 0) and (sy = 0) then
		Direction := '©'
	else if sy > 0 then
		Direction := '«'
	else if sy < 0 then
		Direction := 'ª'
	else
		Exit;
	if FGestureItemList.Count > 0 then begin
		if Items[FGestureItemList.Count - 1] = Direction then
			Exit;
	end else begin
		//ƒWƒFƒXƒ`ƒƒ[ŠJn
		if Assigned(FOnGestureStart) then
			FOnGestureStart(Self);
	end;
	AddGesture(Direction);
	if Assigned(FOnGestureMove) then
		FOnGestureMove(Self);
end;

//Œ»İ‚ÌƒWƒFƒXƒ`ƒƒ[‚ÉV‚µ‚¢•ûŒü‚ğ’Ç‰Á
function TMouseGesture.AddGesture(Item: string): Integer;
begin
	Result := FGestureItemList.Add(Item);
end;

//w’è‚³‚ê‚½index‚Ì“®‚«‚ğ•Ô‚·
function TMouseGesture.Get(Index: Integer): string;
begin
	Result := FGestureItemList[Index];
end;

//w’è‚³‚ê‚½index‚Ì“®‚«‚ğİ’è‚·‚é
procedure TMouseGesture.Put(Index: Integer; Item: string);
begin
	FGestureItemList[Index] := Item;
end;

//ƒWƒFƒXƒ`ƒƒ[•¶š—ñ‚ğ•Ô‚·
function TMouseGesture.GetGestureStr: string;
var
	i: Integer;
begin
	Result := '';
	for i := 0 to FGestureItemList.Count - 1 do
		Result := Result + Items[i];
end;

//ƒWƒFƒXƒ`ƒƒ[‚Ì’·‚³‚ğ•Ô‚·
function TMouseGesture.GetGestureCount: Integer;
begin
	Result := FGestureItemList.Count;
end;

//ƒWƒFƒXƒ`ƒƒ[‚ğƒNƒŠƒA‚·‚é
procedure TMouseGesture.Clear;
begin
	FGestureItemList.Clear;
end;

end.
@


1.9
log
@ãƒ¬ã‚¹ã‚¨ãƒ‡ã‚£ã‚¿,ã‚­ãƒ¼è¨­å®šã§ãƒã‚¦ã‚¹ã‚¸ã‚§ã‚¹ãƒãƒ£ãƒ¼ã®å…¥åŠ›ãŒã‚¯ãƒªã‚¢ã•ã‚Œãªã„ä¸å…·åˆã®ä¿®æ­£
@
text
@d12 1
a12 1
		FHook: Integer;
@


1.8
log
@ãƒã‚¦ã‚¹ã‚¸ã‚§ã‚¹ãƒãƒ£ãƒ¼ã§ã€ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚’å‘¼ã³å‡ºã™ã¨ãå‰ã«ã€
ã‚¸ã‚§ã‚¹ãƒãƒ£ãƒ¼ã‚’ã‚¯ãƒªã‚¢ã™ã‚‹ã‚ˆã†ã«å¤‰æ›´
@
text
@d39 1
a39 1
		procedure ClearGesture;
d68 1
a68 1
	ClearGesture;
d167 1
a167 1
                        ClearGesture;
d244 1
a244 1
procedure TMouseGesture.ClearGesture;
@


1.7
log
@å³ã‚¯ãƒªãƒƒã‚¯ã®ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãƒ¡ãƒ‹ãƒ¥ãƒ¼ä¸Šã®ãƒã‚¦ã‚¹ã‚¸ã‚§ã‚¹ãƒãƒ£ãƒ¼ã‚’ç„¡åŠ¹ã«ã§ãã‚‹ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã‚’è¿½åŠ ã€‚
ã‚¢ãƒ‰ãƒ¬ã‚¹ãƒãƒ¼ã«ãƒ•ã‚©ãƒ¼ã‚«ã‚¹ã‚’å½“ã¦ã‚‹ã‚·ãƒ§ãƒ¼ãƒˆã‚«ãƒƒãƒˆã‚’è¿½åŠ ã€‚
@
text
@a27 1
		procedure ClearGesture;
d39 1
d164 1
a164 1
					if Assigned(FOnGestureEnd) then
d166 3
a168 1
					ClearGesture;
@


1.6
log
@datè½ã¡ã‚¹ãƒ¬ã®åŒºåˆ¥ã‚’è¿½åŠ ã—ãŸã®ã§ã€ã‚¹ãƒ¬ãƒƒãƒ‰ä¸€è¦§ã‚’ãã‚Œã§çµã‚Šè¾¼ã‚ã‚‹ã‚ˆã†ã«ã—ãŸ
@
text
@d52 3
d122 1
a123 1
				SetCapture(FHandle);
d136 2
a137 2
				Result := True;
			end;
d140 9
a148 1
			if not FCancelMode then begin
@


1.5
log
@ãƒã‚¦ã‚¹ã‚¸ã‚§ã‚¹ãƒãƒ£ãƒ¼-ã®ä¸å…·åˆã¨ãƒ¬ã‚¹ç•ªæŒ‡å®šURLã‚’è¸ã‚“ã ã¨ãã®å‡¦ç†ç”¨ã«
TThreadItemã‚’æ‹¡å¼µ
@
text
@a108 1
	r: LongBool;
@


1.4
log
@1.3ã®ç›´ã—æ–¹ã ã¨ã€ãƒ¡ã‚¤ãƒ³Sãƒ•ã‚©ãƒ¼ãƒ ã®ãƒãƒƒãƒ—ã‚¢ãƒƒãƒ—ãŒãŠã‹ã—ããªã‚‹ã®ã§ã€ï¼‘.2ç›¸å½“ã«
ãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯ã€‚
@
text
@d109 1
d150 1
a150 1
			else begin
@


1.3
log
@ãƒã‚¦ã‚¹ã‚¸ã‚§ã‚¹ãƒãƒ£ãƒ¼æœ‰åŠ¹æ™‚ã«ç”»åƒãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ä¸Šã§å³ã‚¯ãƒªãƒƒã‚¯ãŒ
åŠ¹ã‹ãªã„ä¸å…·åˆã®ä¿®æ­£ã€‚
@
text
@d137 8
a144 5
			FBeginGesture := True;
			FLastTime := 0;
			FLastPoint := Point(x, y);
			FStartPoint := Point(x, y);
			SetCapture(FHandle);
d147 15
a161 6
			FBeginGesture := False;
			ReleaseCapture;
			if FGestureItemList.Count <> 0 then begin
				if Assigned(FOnGestureEnd) then
					FOnGestureEnd(Self);
				ClearGesture;
@


1.2
log
@ãƒã‚›ã‚¿50ï¼ˆ1.50.1.599)ã¾ã§ã®å¤‰æ›´åˆ†ã‚’ãƒãƒ¼ã‚¸
@
text
@a132 4
				//ƒ}ƒEƒX‚ğÄİ’è
				if (hwnd <> 0) and (hwnd <> FHandle) then
					SetCapture(hwnd);
				
d137 5
a141 8
			if not FCancelMode then begin
				FBeginGesture := True;
				FLastTime := 0;
				FLastPoint := Point(x, y);
				FStartPoint := Point(x, y);
				CheckAction := True;
				SetCapture(FHandle);
			end;
d144 6
a149 15
			if FCancelMode then
				FCancelMode := False
			else begin
				FBeginGesture := False;
				ReleaseCapture;
				if FGestureItemList.Count <> 0 then begin
					if Assigned(FOnGestureEnd) then
						FOnGestureEnd(Self);
					ClearGesture;
				end else begin
					FCancelMode := True;
					//ƒWƒFƒXƒ`ƒƒ[‚¶‚á‚È‚©‚Á‚½ê‡Aƒ}ƒEƒXDOWN,UP‚ğƒGƒ~ƒ…ƒŒ[ƒg
					mouse_event(MOUSEEVENTF_ABSOLUTE or MOUSEEVENTF_RIGHTDOWN, FStartPoint.X, FStartPoint.Y, 0, 0);
					mouse_event(MOUSEEVENTF_ABSOLUTE or MOUSEEVENTF_RIGHTUP, x, y, 0, 0);
				end;
@


1.1
log
@ãƒã‚¦ã‚¹ã‚¸ã‚§ã‚¹ãƒãƒ£ã®è¿½åŠ ã€‚
build557
@
text
@d108 1
d114 6
d123 1
a123 1
				if Sqrt(dp.X * dp.X + dp.Y * dp.Y) > FMargin then begin
d125 1
a125 1
					if dp.X > dp.Y / 3 then
d127 1
a127 1
					if dp.Y > dp.X / 3 then
d133 4
@


1.1.4.1
log
@ãƒã‚¦ã‚¹ã‚¸ã‚§ã‚¹ãƒãƒ£ãƒ¼ã®ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆä¸Šã¨ã‹ã§ã®å‹•ä½œã®ä¿®æ­£
@
text
@a107 1
	hwnd: THandle;
a112 6
				//¡ƒ}ƒEƒX‚ğƒLƒƒƒvƒ`ƒƒ[‚µ‚Ä‚¢‚é‚Ì‚ğ“¾‚é
				hwnd := GetCapture;
				//ƒ}ƒEƒXƒWƒFƒXƒ`ƒƒ[‚Ì‘ÎÛ‚Æˆá‚¤‚Æ‚«‚ÍAŠJ•ú‚·‚é
				if (hwnd <> 0) and (hwnd <> FHandle) then begin
					ReleaseCapture;
				end;
d116 1
a116 1
				if (dp.X * dp.X + dp.Y * dp.Y) > (FMargin * FMargin) then begin
d118 1
a118 1
					if dp.X > dp.Y div 3 then
d120 1
a120 1
					if dp.Y > dp.X div 3 then
a125 4
				//ƒ}ƒEƒX‚ğÄİ’è
				if (hwnd <> 0) and (hwnd <> FHandle) then
					SetCapture(hwnd);
				
@

